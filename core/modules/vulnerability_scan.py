import subprocess
import json
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
from .base import BaseModule

class VulnerabilityScanModule(BaseModule):
    def __init__(self, framework):
        super().__init__(framework)
        self.tools = {
            'nuclei': self._run_nuclei,
            'wpscan': self._run_wpscan,
            'nikto': self._run_nikto,
            'sqlmap': self._run_sqlmap,
            'dalfox': self._run_dalfox,
            'ghauri': self._run_ghauri,
            'metasploit': self._run_metasploit,
            'kxss': self._run_kxss,
            'crlfuzz': self._run_crlfuzz
        }

    def run(self):
        """Execute vulnerability scanning tools"""
        self.logger.info("Starting vulnerability scanning phase...")
        results = {}
        
        # Get live web targets
        targets = self._get_live_targets()
        
        with ThreadPoolExecutor(max_workers=self.config['tools']['threads']) as executor:
            future_to_tool = {
                executor.submit(tool_func, targets): tool_name
                for tool_name, tool_func in self.tools.items()
            }
            
            for future in as_completed(future_to_tool):
                tool_name = future_to_tool[future]
                try:
                    results[tool_name] = future.result()
                except Exception as e:
                    self.logger.error(f"Error running {tool_name}: {str(e)}")
                    results[tool_name] = {'error': str(e)}
        
        self._save_results(results)
        return results

    def _run_nuclei(self, targets):
        """Run Nuclei scanner"""
        try:
            if not self._check_tool_exists('nuclei'):
                raise Exception("nuclei not found. Please install it first.")
            
            input_file = os.path.join(self.framework.output_dir, 'nuclei_targets.txt')
            output_file = os.path.join(self.framework.output_dir, 'nuclei_results.json')
            
            # Write targets to input file
            with open(input_file, 'w') as f:
                f.write('\n'.join(targets))
            
            cmd = [
                'nuclei',
                '-l', input_file,
                '-json',
                '-o', output_file,
                '-silent',
                '-c', '50',  # Concurrent requests
                '-rl', '150',  # Rate limit
                '-stats',
                '-severity', 'low,medium,high,critical'
            ]
            
            subprocess.run(cmd, check=True)
            
            results = {}
            if os.path.exists(output_file):
                with open(output_file) as f:
                    for line in f:
                        try:
                            finding = json.loads(line)
                            target = finding.get('host', '')
                            if target not in results:
                                results[target] = []
                            results[target].append(finding)
                        except json.JSONDecodeError:
                            continue
            
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Nuclei error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in nuclei: {str(e)}")
            return {'error': str(e)}

    def _run_wpscan(self, targets):
        """Run WPScan tool"""
        try:
            if not self._check_tool_exists('wpscan'):
                raise Exception("wpscan not found. Please install it first.")
            
            results = {}
            for target in targets:
                output_file = os.path.join(
                    self.framework.output_dir, 
                    f'wpscan_{target.replace("://", "_")}.json'
                )
                
                cmd = [
                    'wpscan',
                    '--url', target,
                    '--format', 'json',
                    '--output', output_file,
                    '--random-user-agent',
                    '--detection-mode', 'aggressive',
                    '--enumerate', 'vp,vt,tt,cb,dbe,u,m'
                ]
                
                # Add API token if available
                if 'wpscan' in self.config.get('api_keys', {}):
                    cmd.extend(['--api-token', self.config['api_keys']['wpscan']])
                
                subprocess.run(cmd, check=True)
                
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        results[target] = json.load(f)
                
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"WPScan error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in wpscan: {str(e)}")
            return {'error': str(e)}

    def _run_nikto(self, targets):
        """Run Nikto scanner"""
        try:
            if not self._check_tool_exists('nikto'):
                raise Exception("nikto not found. Please install it first.")
            
            results = {}
            for target in targets:
                output_file = os.path.join(
                    self.framework.output_dir, 
                    f'nikto_{target.replace("://", "_")}.json'
                )
                
                cmd = [
                    'nikto',
                    '-h', target,
                    '-Format', 'json',
                    '-output', output_file,
                    '-Tuning', '123457890abcde',
                    '-maxtime', '1h'
                ]
                
                subprocess.run(cmd, check=True)
                
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        results[target] = json.load(f)
                
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Nikto error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in nikto: {str(e)}")
            return {'error': str(e)}

    def _run_sqlmap(self, targets):
        """Run SQLMap scanner"""
        try:
            if not self._check_tool_exists('sqlmap'):
                raise Exception("sqlmap not found. Please install it first.")
            
            results = {}
            for target in targets:
                output_dir = os.path.join(
                    self.framework.output_dir, 
                    f'sqlmap_{target.replace("://", "_")}'
                )
                
                cmd = [
                    'sqlmap',
                    '-u', target,
                    '--batch',
                    '--random-agent',
                    '--level', '2',
                    '--risk', '2',
                    '--output-dir', output_dir,
                    '--forms',
                    '--crawl', '2',
                    '--threads', '4'
                ]
                
                subprocess.run(cmd, check=True)
                
                # Process results
                log_file = os.path.join(output_dir, 'log')
                if os.path.exists(log_file):
                    with open(log_file) as f:
                        results[target] = f.read()
                
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"SQLMap error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in sqlmap: {str(e)}")
            return {'error': str(e)}

    def _run_ghauri(self, targets):
        """Run Ghauri scanner"""
        try:
            if not self._check_tool_exists('ghauri'):
                raise Exception("ghauri not found. Please install it first.")
            
            results = {}
            for target in targets:
                output_file = os.path.join(
                    self.framework.output_dir, 
                    f'ghauri_{target.replace("://", "_")}.txt'
                )
                
                cmd = [
                    'ghauri',
                    '-u', target,
                    '--batch',
                    '--output', output_file,
                    '--forms',
                    '--crawl'
                ]
                
                subprocess.run(cmd, check=True)
                
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        results[target] = f.read()
                
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Ghauri error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in ghauri: {str(e)}")
            return {'error': str(e)}

    def _run_kxss(self, targets):
        """Run kxss XSS scanner"""
        try:
            if not self._check_tool_exists('kxss'):
                raise Exception("kxss not found. Please install it first.")
            
            results = {}
            for target in targets:
                output_file = os.path.join(
                    self.framework.output_dir, 
                    f'kxss_{target.replace("://", "_")}.txt'
                )
                
                # First gather parameters using waybackurls
                params_cmd = f"echo {target} | waybackurls"
                urls = subprocess.run(
                    params_cmd, 
                    shell=True, 
                    capture_output=True, 
                    text=True
                ).stdout.splitlines()
                
                # Then scan with kxss
                if urls:
                    scan_cmd = f"echo '{chr(10).join(urls)}' | kxss"
                    process = subprocess.run(
                        scan_cmd, 
                        shell=True, 
                        capture_output=True, 
                        text=True
                    )
                    
                    with open(output_file, 'w') as f:
                        f.write(process.stdout)
                    
                    results[target] = process.stdout.splitlines()
                
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"KXSS error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in kxss: {str(e)}")
            return {'error': str(e)}

    def _run_crlfuzz(self, targets):
        """Run CRLFuzz scanner"""
        try:
            if not self._check_tool_exists('crlfuzz'):
                raise Exception("crlfuzz not found. Please install it first.")
            
            results = {}
            for target in targets:
                output_file = os.path.join(
                    self.framework.output_dir, 
                    f'crlfuzz_{target.replace("://", "_")}.txt'
                )
                
                cmd = [
                    'crlfuzz',
                    '-u', target,
                    '-o', output_file,
                    '-s'  # Silent mode
                ]
                
                subprocess.run(cmd, check=True)
                
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        results[target] = f.read().splitlines()
                
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"CRLFuzz error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in crlfuzz: {str(e)}")
            return {'error': str(e)}

    def _run_dalfox(self, targets):
        """Run dalfox XSS scanner"""
        try:
            input_file = os.path.join(self.framework.output_dir, 'dalfox_targets.txt')
            output_file = os.path.join(self.framework.output_dir, 'dalfox_results.json')
            
            with open(input_file, 'w') as f:
                f.write('\n'.join(targets))
            
            cmd = [
                'dalfox', 'file',
                input_file,
                '--json-output', output_file,
                '--skip-bav',
                '--skip-mining-all',
                '--skip-mining-dict',
                '--skip-mining-params'
            ]
            
            subprocess.run(cmd, check=True)
            
            with open(output_file) as f:
                return json.load(f)
        except subprocess.CalledProcessError as e:
            raise Exception(f"Dalfox error: {e.stderr}")

    def _run_metasploit(self, targets):
        """Run Metasploit scanner"""
        try:
            if not self._check_tool_exists('msfconsole'):
                raise Exception("metasploit-framework not found. Please install it first.")
            
            results = {}
            for target in targets:
                output_file = os.path.join(
                    self.framework.output_dir, 
                    f'msf_{target.replace("://", "_")}.txt'
                )
                
                # Create resource script for automated scanning
                rc_file = os.path.join(self.framework.output_dir, 'msf_scan.rc')
                with open(rc_file, 'w') as f:
                    f.write(f"""
use auxiliary/scanner/http/dir_scanner
set RHOSTS {target.split('://')[1]}
set THREADS 10
run
use auxiliary/scanner/http/http_version
set RHOSTS {target.split('://')[1]}
run
use auxiliary/scanner/http/robots_txt
set RHOSTS {target.split('://')[1]}
run
exit
                    """)
                
                # Run Metasploit with resource script
                cmd = [
                    'msfconsole',
                    '-q',  # Quiet mode
                    '-r', rc_file,
                    '-o', output_file
                ]
                
                subprocess.run(cmd, check=True)
                
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        results[target] = f.read()
                
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Metasploit error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in metasploit: {str(e)}")
            return {'error': str(e)}

    def _get_live_targets(self):
        """Get live targets from web probing results"""
        probing_file = os.path.join(self.framework.output_dir, 'web_probing_results.json')
        targets = []
        
        if os.path.exists(probing_file):
            try:
                with open(probing_file) as f:
                    data = json.load(f)
                    for tool_results in data.values():
                        if isinstance(tool_results, list):
                            for result in tool_results:
                                if isinstance(result, dict) and 'url' in result:
                                    targets.append(result['url'])
            except Exception as e:
                self.logger.error(f"Error reading web probing results: {str(e)}")
        
        if not targets:
            targets = [f"http://{self.framework.args.domain}"]
        
        return list(set(targets))

    # ... (other existing methods) ... 