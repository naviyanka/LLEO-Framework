from typing import Dict, Any, List, Optional, Type
from pathlib import Path
import json
from .base_module import BaseModule, ToolResult
import asyncio
from dataclasses import dataclass
import os
import subprocess
import shutil
from datetime import datetime
from core.utils.rate_limiter import RateLimiter
from core.utils.cache_manager import CacheManager

@dataclass
class VulnScanResult:
    tool: str
    raw_output: Optional[Path] = None
    findings: List[Dict[str, Any]] = None
    error: Optional[str] = None

class VulnerabilityScanModule(BaseModule):
    def __init__(self, framework):
        super().__init__(framework)
        self.tools = {
            'wpscan': self._run_wpscan,
            'nikto': self._run_nikto,
            'sqlmap': self._run_sqlmap,
            'dalfox': self._run_dalfox,
            'ghauri': self._run_ghauri,
            'kxss': self._run_kxss,
            'crlfuzz': self._run_crlfuzz
        }
        self.running_tasks: Set[asyncio.Task] = set()
        self.max_concurrent_tasks = self.config.tools.threads
        self.rate_limiter = RateLimiter(
            calls_per_second=self.config.tools.rate_limit,
            burst_size=self.config.tools.burst_size
        )
        self.cache = CacheManager(
            cache_dir=self.output_dir / 'cache',
            ttl=self.config.performance.cache_ttl
        )

    async def setup(self) -> None:
        """Setup module resources"""
        await super().setup()
        self.logger.info("Setting up vulnerability scan module...")
        
        # Verify tool versions
        for tool, min_version in self.get_required_tools().items():
            try:
                if tool == 'wpscan':
                    result = await self.execute_tool(['wpscan', '--no-update', '--version'])
                elif tool == 'nikto':
                    result = await self.execute_tool(['nikto', '-Version', '-Tuning', 'x'])
                elif tool == 'sqlmap':
                    result = await self.execute_tool(['sqlmap', '--version'])
                elif tool == 'dalfox':
                    result = await self.execute_tool(['dalfox', 'version'])
                elif tool == 'ghauri':
                    result = await self.execute_tool(['ghauri', '-v'])
                elif tool == 'kxss':
                    result = await self.execute_tool(['kxss', '-version'])
                elif tool == 'crlfuzz':
                    result = await self.execute_tool(['crlfuzz', 'version'])
                else:
                    result = await self.execute_tool([tool, '--version'])
                    
                if result.success:
                    version = result.output
                    if version:
                        self.logger.info(f"Found {tool} version {version}")
                    else:
                        self.logger.warning(f"Could not determine {tool} version")
                else:
                    self.logger.error(f"Error checking {tool} version: {result.error}")
            except Exception as e:
                self.logger.error(f"Error checking {tool} version: {e}")

        # Create necessary directories
        for dir_name in ['raw', 'processed', 'temp']:
            dir_path = self.output_dir / dir_name
            dir_path.mkdir(parents=True, exist_ok=True)
        
        # Initialize rate limiter monitoring
        await self.rate_limiter.start_monitoring()

    async def cleanup(self) -> None:
        """Cleanup module resources"""
        try:
            # Stop rate limiter monitoring
            await self.rate_limiter.stop_monitoring()
            
            # Cancel any running tasks
            for task in self.running_tasks:
                if not task.done():
                    task.cancel()
            
            # Wait for tasks to complete
            if self.running_tasks:
                await asyncio.gather(*self.running_tasks, return_exceptions=True)
            
            # Clean up temporary files
            temp_dir = self.output_dir / 'temp'
            if temp_dir.exists():
                shutil.rmtree(temp_dir)
            
            await super().cleanup()
            
        except Exception as e:
            self.logger.error(f"Error during cleanup: {e}")

    def get_dependencies(self) -> List[Type]:
        """Get module dependencies"""
        return ['web_probing']

    def get_event_handlers(self) -> Dict[str, callable]:
        """Get event handlers"""
        return {}

    def get_required_tools(self) -> Dict[str, Optional[str]]:
        """Return required tools and their minimum versions"""
        return {
            'wpscan': '3.8.0',
            'nikto': '2.1.6',
            'sqlmap': '1.4.0',
            'dalfox': '2.7.0',
            'ghauri': '1.0.0',
            'kxss': '1.0.0',
            'crlfuzz': '1.4.0'
        }

    async def _run_implementation(self) -> Dict[str, Any]:
        """Actual module implementation"""
        return await self.run()

    async def run(self) -> Dict[str, Any]:
        """Run vulnerability scanning tools"""
        try:
            await self.setup()
            self.logger.info("Starting vulnerability scan...")
            
            results = {
                'vulnerabilities': [],
                'errors': []
            }
            
            targets = await self._get_targets()
            
            for target in targets:
                self.logger.info(f"Running wpscan on {target}")
                try:
                    wpscan_results = await self._run_wpscan(target)
                    if wpscan_results and isinstance(wpscan_results, dict):
                        results['vulnerabilities'].extend(wpscan_results.get('vulnerabilities', []))
                except Exception as e:
                    self.logger.error(f"Error in wpscan on {target}: {e}")
                    results['errors'].append(f"WPScan error: {str(e)}")
                
                self.logger.info(f"Running nikto on {target}")
                try:
                    nikto_results = await self._run_nikto(target)
                    if nikto_results and isinstance(nikto_results, dict):
                        results['vulnerabilities'].extend(nikto_results.get('vulnerabilities', []))
                except Exception as e:
                    self.logger.error(f"Error in nikto on {target}: {e}")
                    results['errors'].append(f"Nikto error: {str(e)}")
                
                self.logger.info(f"Running sqlmap on {target}")
                try:
                    sqlmap_results = await self._run_sqlmap(target)
                    if sqlmap_results and isinstance(sqlmap_results, dict):
                        results['vulnerabilities'].extend(sqlmap_results.get('vulnerabilities', []))
                except Exception as e:
                    self.logger.error(f"Error in sqlmap on {target}: {e}")
                    results['errors'].append(f"SQLMap error: {str(e)}")
                
                self.logger.info(f"Running dalfox on {target}")
                try:
                    dalfox_results = await self._run_dalfox(target)
                    if dalfox_results and isinstance(dalfox_results, dict):
                        results['vulnerabilities'].extend(dalfox_results.get('vulnerabilities', []))
                except Exception as e:
                    self.logger.error(f"Error in dalfox on {target}: {e}")
                    results['errors'].append(f"Dalfox error: {str(e)}")
                
                self.logger.info(f"Running ghauri on {target}")
                try:
                    ghauri_results = await self._run_ghauri(target)
                    if ghauri_results and isinstance(ghauri_results, dict):
                        results['vulnerabilities'].extend(ghauri_results.get('vulnerabilities', []))
                except Exception as e:
                    self.logger.error(f"Error in ghauri on {target}: {e}")
                    results['errors'].append(f"Ghauri error: {str(e)}")
                
                self.logger.info(f"Running kxss on {target}")
                try:
                    kxss_results = await self._run_kxss(target)
                    if kxss_results and isinstance(kxss_results, dict):
                        results['vulnerabilities'].extend(kxss_results.get('vulnerabilities', []))
                except Exception as e:
                    self.logger.error(f"Error in kxss on {target}: {e}")
                    results['errors'].append(f"KXSS error: {str(e)}")
                
                self.logger.info(f"Running crlfuzz on {target}")
                try:
                    crlfuzz_results = await self._run_crlfuzz(target)
                    if crlfuzz_results and isinstance(crlfuzz_results, dict):
                        results['vulnerabilities'].extend(crlfuzz_results.get('vulnerabilities', []))
                except Exception as e:
                    self.logger.error(f"Error in crlfuzz on {target}: {e}")
                    results['errors'].append(f"CRLFuzz error: {str(e)}")
            
            # Remove duplicates while preserving order
            results['vulnerabilities'] = list(dict.fromkeys(results['vulnerabilities']))
            
            return results
            
        except Exception as e:
            self.logger.error(f"Critical error in vulnerability scan module: {e}")
            return {'error': str(e)}
        finally:
            await self.cleanup()

    async def _get_targets(self) -> List[str]:
        """Get targets from web probing results"""
        try:
            results = await self.framework.session_manager.get_results("web_probing")
            if not results:
                self.logger.warning("No web probing results found, using target domain")
                return [f"http://{self.framework.target}"]
            
            targets = []
            for result in results:
                if isinstance(result, dict) and "url" in result:
                    targets.append(result["url"])
            
            if not targets:
                self.logger.warning("No valid targets found in web probing results, using target domain")
                targets = [f"http://{self.framework.target}"]
            
            return targets
        except Exception as e:
            self.logger.error(f"Error getting targets: {str(e)}")
            return [f"http://{self.framework.target}"]

    async def _run_wpscan(self, target: str) -> Dict[str, Any]:
        """Run WPScan for WordPress vulnerability scanning"""
        try:
            output_file = self.output_dir / 'raw' / f'wpscan_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
            output_file.parent.mkdir(parents=True, exist_ok=True)
            
            cmd = [
                'wpscan',
                '--url', target,
                '--format', 'json',
                '--output', str(output_file),
                '--random-user-agent',
                '--detection-mode', 'aggressive',
                '--plugins-detection', 'aggressive',
                '--enumerate', 'vp,vt,tt,cb,dbe,u,m',
                '--api-token', self.config.api_keys.get('wpscan', ''),
                '--max-threads', str(self.config.tools.threads)
            ]
            
            result = await self.execute_tool(cmd, timeout=300)  # 5 minutes timeout
            if not result.success:
                return {'error': result.error}
            
            try:
                if output_file.exists():
                    with open(output_file) as f:
                        return json.load(f)
                return {'error': 'No output file generated'}
            except Exception as e:
                return {'error': f"Error processing wpscan results: {e}"}
        except Exception as e:
            return {'error': f"Error in wpscan: {e}"}

    async def _run_nikto(self, target: str) -> Dict[str, Any]:
        """Run Nikto web server scanner"""
        try:
            output_file = self.output_dir / 'raw' / f'nikto_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
            output_file.parent.mkdir(parents=True, exist_ok=True)
            
            cmd = [
                'nikto',
                '-h', target,
                '-Format', 'json',
                '-output', str(output_file),
                '-Tuning', '123457890abc',
                '-maxtime', '1h',
                '-nointeractive'
            ]
            
            result = await self.execute_tool(cmd, timeout=3600)  # 1 hour timeout
            if not result.success:
                return {'error': result.error}
            
            try:
                if output_file.exists():
                    with open(output_file) as f:
                        return json.load(f)
                return {'error': 'No output file generated'}
            except Exception as e:
                return {'error': f"Error processing nikto results: {e}"}
        except Exception as e:
            return {'error': f"Error in nikto: {e}"}

    async def _run_sqlmap(self, target: str) -> Dict[str, Any]:
        """Run SQLMap for SQL injection testing"""
        try:
            output_dir = self.output_dir / 'raw' / f'sqlmap_{datetime.now().strftime("%Y%m%d_%H%M%S")}'
            output_dir.mkdir(parents=True, exist_ok=True)
            
            cmd = [
                'sqlmap',
                '-u', target,
                '--batch',
                '--random-agent',
                '--level', '2',
                '--risk', '2',
                '--threads', str(self.config.tools.threads),
                '--output-dir', str(output_dir),
                '--json-output'
            ]
            
            result = await self.execute_tool(cmd, timeout=1800)  # 30 minutes timeout
            if not result.success:
                return {'error': result.error}
            
            try:
                results_file = output_dir / 'results.json'
                if results_file.exists():
                    with open(results_file) as f:
                        return json.load(f)
                return {'error': 'No output file generated'}
            except Exception as e:
                return {'error': f"Error processing sqlmap results: {e}"}
        except Exception as e:
            return {'error': f"Error in sqlmap: {e}"}

    async def _run_dalfox(self, target: str) -> Dict[str, Any]:
        """Run Dalfox for XSS scanning"""
        try:
            output_file = self.output_dir / 'raw' / f'dalfox_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
            output_file.parent.mkdir(parents=True, exist_ok=True)
            
            cmd = [
                'dalfox',
                'url',
                target,
                '--format', 'json',
                '--output', str(output_file),
                '--worker', str(self.config.tools.threads),
                '--silence'
            ]
            
            result = await self.execute_tool(cmd, timeout=900)  # 15 minutes timeout
            if not result.success:
                return {'error': result.error}
            
            try:
                if output_file.exists():
                    with open(output_file) as f:
                        return json.load(f)
                return {'error': 'No output file generated'}
            except Exception as e:
                return {'error': f"Error processing dalfox results: {e}"}
        except Exception as e:
            return {'error': f"Error in dalfox: {e}"}

    async def _run_ghauri(self, target: str) -> Dict[str, Any]:
        """Run Ghauri for SQL injection testing"""
        try:
            output_file = self.output_dir / 'raw' / f'ghauri_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
            output_file.parent.mkdir(parents=True, exist_ok=True)
            
            cmd = [
                'ghauri',
                '-u', target,
                '--json', str(output_file),
                '--threads', str(self.config.tools.threads),
                '--batch'
            ]
            
            result = await self.execute_tool(cmd, timeout=1200)  # 20 minutes timeout
            if not result.success:
                return {'error': result.error}
            
            try:
                if output_file.exists():
                    with open(output_file) as f:
                        return json.load(f)
                return {'error': 'No output file generated'}
            except Exception as e:
                return {'error': f"Error processing ghauri results: {e}"}
        except Exception as e:
            return {'error': f"Error in ghauri: {e}"}

    async def _run_kxss(self, target: str) -> Dict[str, Any]:
        """Run kxss for XSS scanning"""
        try:
            output_file = self.output_dir / 'raw' / f'kxss_{datetime.now().strftime("%Y%m%d_%H%M%S")}.txt'
            output_file.parent.mkdir(parents=True, exist_ok=True)
            
            # First, crawl the target with katana
            crawl_cmd = [
                'katana',
                '-u', target,
                '-jc',
                '-silent'
            ]
            
            crawl_result = await self.execute_tool(crawl_cmd, timeout=300)  # 5 minutes timeout
            if not crawl_result.success:
                return {'error': crawl_result.error}
            
            # Then run kxss on the discovered URLs
            cmd = [
                'kxss',
                '-o', str(output_file)
            ]
            
            result = await self.execute_tool(cmd, timeout=600)  # 10 minutes timeout
            if not result.success:
                return {'error': result.error}
            
            try:
                if output_file.exists():
                    with open(output_file) as f:
                        return {'vulnerabilities': [line.strip() for line in f if line.strip()]}
                return {'error': 'No output file generated'}
            except Exception as e:
                return {'error': f"Error processing kxss results: {e}"}
        except Exception as e:
            return {'error': f"Error in kxss: {e}"}

    async def _run_crlfuzz(self, target: str) -> Dict[str, Any]:
        """Run CRLFuzz for CRLF injection scanning"""
        try:
            output_file = self.output_dir / 'raw' / f'crlfuzz_{datetime.now().strftime("%Y%m%d_%H%M%S")}.json'
            output_file.parent.mkdir(parents=True, exist_ok=True)
            
            cmd = [
                'crlfuzz',
                'scan',
                '-u', target,
                '-o', str(output_file),
                '-s'  # Silent mode
            ]
            
            result = await self.execute_tool(cmd, timeout=600)  # 10 minutes timeout
            if not result.success:
                return {'error': result.error}
            
            try:
                if output_file.exists():
                    with open(output_file) as f:
                        return json.load(f)
                return {'error': 'No output file generated'}
            except Exception as e:
                return {'error': f"Error processing crlfuzz results: {e}"}
        except Exception as e:
            return {'error': f"Error in crlfuzz: {e}"}

    async def _run_metasploit(self, targets):
        """Run Metasploit scanner"""
        try:
            if not self._check_tool_exists('msfconsole'):
                raise Exception("metasploit-framework not found. Please install it first.")
            
            results = {}
            for target in targets:
                output_file = os.path.join(
                    self.framework.output_dir, 
                    f'msf_{target.replace("://", "_")}.txt'
                )
                
                # Create resource script for automated scanning
                rc_file = os.path.join(self.framework.output_dir, 'msf_scan.rc')
                with open(rc_file, 'w') as f:
                    f.write(f"""
use auxiliary/scanner/http/dir_scanner
set RHOSTS {target.split('://')[1]}
set THREADS 10
run
use auxiliary/scanner/http/http_version
set RHOSTS {target.split('://')[1]}
run
use auxiliary/scanner/http/robots_txt
set RHOSTS {target.split('://')[1]}
run
exit
                    """)
                
                # Run Metasploit with resource script
                cmd = [
                    'msfconsole',
                    '-q',  # Quiet mode
                    '-r', rc_file,
                    '-o', output_file
                ]
                
                subprocess.run(cmd, check=True)
                
                if os.path.exists(output_file):
                    with open(output_file) as f:
                        results[target] = f.read()
                
            return results
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Metasploit error: {e.stderr if hasattr(e, 'stderr') else str(e)}")
            return {'error': str(e)}
        except Exception as e:
            self.logger.error(f"Unexpected error in metasploit: {str(e)}")
            return {'error': str(e)}

    async def _get_live_targets(self) -> List[str]:
        """Get live targets from web probing results with improved error handling"""
        probing_file = self.output_dir / 'web_probing_results.json'
        
        if not probing_file.exists():
            self.logger.warning("No web probing results found, using target domain")
            return [f"http://{self.framework.args.domain}"]
            
        try:
            data = json.loads(probing_file.read_text())
            targets = []
            for tool_results in data.values():
                if isinstance(tool_results, dict) and 'live_hosts' in tool_results:
                    targets.extend(tool_results['live_hosts'])
            return list(set(targets)) if targets else [f"http://{self.framework.args.domain}"]
        except Exception as e:
            self.logger.error(f"Error reading web probing results: {e}")
            return [f"http://{self.framework.args.domain}"]


    # ... (other existing methods) ... 